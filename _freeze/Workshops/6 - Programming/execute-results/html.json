{
  "hash": "6b59d67dedf07f6ee4c94e77c8a51946",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Programming Essentials\n--- \n\nIn this workshop we cover the building blocks for developing more complex code, looking at\n\n* Understanding variable types and methods\n* Conditionals\n* Loops\n* Custom functions and modules\n\n## Looking under the hood: what makes `ints` *ints*?\n\nPython is a high level programming language. Its features are often inspired by C and C++, and is itself built in C/C++.\n\nOne of the major innovations of C++, and object-oriented programming in general, are **classes**. We won't go over how to write your own - it's beyond the scope of this workshop - but they're worth a conceptual understanding.\n\nEssentially, all Python variables follow a specific template, known as its *class* or *type*. It's safe to use these interchangebly here. The class is a general template for the variable and it defines what *methods* (functions) and *attributes* (variables) live *inside the variable*.\n\nInside the variable? Where? Well, a variables contain more than just their value. We use the `.` operator to access anything besides the value that lives in the variable. For example, all strings have a function called `.upper()` that makes them uppercase:\n\n::: {#aedd5ba9 .cell execution_count=1}\n``` {.python .cell-code}\nrandom_string = \"Hello, this is a sentence.\"\nprint(random_string.upper())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHELLO, THIS IS A SENTENCE.\n```\n:::\n:::\n\n\nLet me emphasise that **all strings have `.upper()`**. That makes `upper()` a **method** of strings. \n\nIn other words, a class is like an empty form that needs filling. The form **string** has a field called `upper()` that is filled with the function as defined above.\n\n## Directing traffic with conditionals\nIn the first half of this session we'll look at two types of control flows: **conditionals** and **loops**.\n\nConditionals allow you to put \"gates\" in your code, only running sections if a certain **condition** is true. They are common to most programming languages.\n\nIn Python, they are called `if` statements, because you use the `if` command. For example,\n\n::: {#37c4894d .cell execution_count=2}\n``` {.python .cell-code}\nif 5 > 0:\n    print(\"We're inside the if statement\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWe're inside the if statement\n```\n:::\n:::\n\n\nThe line `print(\"We're inside the if statement\")` **will only run if `5 > 0` is true**. If not, it'll get skipped.\n\nIndents are essential. Only indented code will be governed by conditional\n\n::: {#61fafcf3 .cell execution_count=3}\n``` {.python .cell-code}\nif 5 > 0:\n    print(\"We're inside the if statement\")\n\nprint(\"This code always runs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWe're inside the if statement\nThis code always runs\n```\n:::\n:::\n\n\nWatch what happens if we change the condition\n\n::: {#66f85a48 .cell execution_count=4}\n``` {.python .cell-code}\nif 5 > 10:\n    print(\"We're inside the if statement\")\n\nprint(\"This code always runs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis code always runs\n```\n:::\n:::\n\n\nNow, the first line **doesn't run**. That's the essence of a conditional.\n\nThere's not much point to using a condition that will always be true. Typically, you'd use a variable in the condition, for example.\n\n::: {#2a50159b .cell execution_count=5}\n``` {.python .cell-code}\npet_age = 10\n\nif pet_age > 10:\n    print(\"My pet is older than 10\")\n```\n:::\n\n\n### Logical operators\n\nHere is a table of the different operators you can make conditions with. When you run them, they always return either `True` or `False`. \n\n| Operator | True example | Description |\n| --- | --- | --- |\n| `==` | `10 == 10` | Same value and type |\n| `!=` | `\"10\" != 10` | Different value **or** type |\n| `>` | `10 > 5` | Greater than |\n| `>=` | `10 >= 10` | Greater than or equal to |\n| `<` | `5 < 10` | Less than |\n| `<=` | `5 <= 10` | Less than or equal to |\n| `in` | `\"a\" in \"apple\"` | First object exists in the second\n| `not in` | `\"b\" not in \"apple\"` | First object **does not** exist in the second |\n| `and` | `10 == 10 and \"a\" in \"apple\"` | Only true if **both** conditions are true. Same as `&` |\n| `or` | `10 == 10 or \"b\" in \"apple\"` | Always true if **one** condition is true. Same as `\\|` |\n\n### `elif` and `else`\n\n`if` statements only run if the condition is **True**. What happens if its **False**? That's what the `else` command is for, it's like a net that catches anything that slipped past `if`:\n\n::: {#b1017594 .cell execution_count=6}\n``` {.python .cell-code}\npet_age = 5\n\nif pet_age > 10:\n    print(\"My pet is older than 10\")\nelse:\n    print(\"My pet is 10 or younger\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy pet is 10 or younger\n```\n:::\n:::\n\n\n> Don't forget the colon `:`!\n\nCheck what happens when you change the age from 5 to 15.\n\nFinally, what if you wanted to check another condition **only if the first one fails**? That's what `elif` (else-if) is for. It's another if statement but it only runs if the first fails.\n\n::: {#9fcd1f8b .cell execution_count=7}\n``` {.python .cell-code}\npet_age = 5\n\nif pet_age > 10:\n    print(\"My pet is older than 10\")\nelif pet_age < 5:\n    print(\"My pet is younger than 5\")\nelse:\n    print(\"My pet is between 5 and 10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy pet is between 5 and 10\n```\n:::\n:::\n\n\nYou can include as many as you'd like\n\n::: {#c31ee864 .cell execution_count=8}\n``` {.python .cell-code}\npet_age = 5\n\nif pet_age > 10:\n    print(\"My pet is older than 10\")\nelif pet_age < 5:\n    print(\"My pet is younger than 5\")\nelif pet_age < 1:\n    print(\"My pet is freshly born\")\nelse:\n    print(\"My pet is between 5 and 10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy pet is between 5 and 10\n```\n:::\n:::\n\n\n## Repeat after me\n\nSometimes you need to repeat a task multiple times. Sometimes hundreds. Maybe you need to loop through 1 million pieces of data. Not fun.\n\nPython's loops offer us a way to run a section of code multiple times. There are two types: `for` loops, which run the code once for each element in a sequence (like a list or string), and `while` loops, which run until some condition is false.\n\n### `while` loops\nThese are almost the same as `if` statements, except for the fact that they run the code multiple times. Let's begin with a basic conditional\n\n::: {#041acd80 .cell execution_count=9}\n``` {.python .cell-code}\nnumber = 5\n\nif number < 10:\n    print(str(number) + \" is less than 10.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 is less than 10.\n```\n:::\n:::\n\n\n> Using `str(number)` turns the number into a string, which lets us combine it with \" is less than 10.\"\n\nThe `print` statement runs once if the condition is true. \n\nWhat if we wanted to check all the numbers between 5 and 10? We can use a while loop.\n\n::: {#a8a9f40b .cell execution_count=10}\n``` {.python .cell-code}\nnumber = 5\n\nwhile number < 10:\n    print(str(number) + \" is less than 10.\")\n    number = number + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 is less than 10.\n6 is less than 10.\n7 is less than 10.\n8 is less than 10.\n9 is less than 10.\n```\n:::\n:::\n\n\nWe've done two things\n\n1. Replace `if` with `while`\n2. Introduce `number = number + 1` to increase the number each time.\n\n> Without step 2, we'd have an **infinite loop** -- one that never stops, because the condition would always be true!\n\nWhile loops are useful for repeating code an indeterminate number of times.\n\n### `for` loops\nRealistically, you're most likely to use a **for** loop. They're inherently safer (you can't have an infinite loop) and often handier.\n\nIn Python, `for` loops iterate through a sequence, like the objects in a list. This is more like other languages' `foreach`, than most's `for`.\n\nLet's say you have a list of different fruit\n\n::: {#8eabe6a2 .cell execution_count=11}\n``` {.python .cell-code}\nlist_of_fruits = [\"apple\", \"banana\", \"cherry\"]\n```\n:::\n\n\nand you want to run a section of code on `\"apple\"`, then `\"banana\"`, then `\"cherry\"`. Maybe you want to know which ones have the letter \"a\". We can start with a `for` loop\n\n::: {#3c1cb051 .cell execution_count=12}\n``` {.python .cell-code}\nlist_of_fruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor fruit in list_of_fruits:\n    print(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\nbanana\ncherry\n```\n:::\n:::\n\n\nThis loop's job is to print out the variable `fruit`. But where is `fruit` defined? Well, the `for` loop runs `print(fruit)` for every element of `list_of_fruits`, **storing the current element in the variable `fruit`**. If we were to write it out explicitly, it would look like\n\n::: {#9da0e371 .cell execution_count=13}\n``` {.python .cell-code}\nfruit = list_of_fruits[0]\nprint(fruit)\n\nfruit = list_of_fruits[1]\nprint(fruit)\n\nfruit = list_of_fruits[2]\nprint(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\nbanana\ncherry\n```\n:::\n:::\n\n\nLet's return to our goal: working out which ones have an \"a\". We need to put a **conditional** inside the loop:\n\n::: {#f23c5d50 .cell execution_count=14}\n``` {.python .cell-code}\nlist_of_fruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor fruit in list_of_fruits:\n    if \"a\" in fruit:\n        print(\"a is in \" + fruit)\n    else:\n        print(\"a is not in \" + fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na is in apple\na is in banana\na is not in cherry\n```\n:::\n:::\n\n\n### Using `range`\n\nThere's a special Python object which is useful for loops, the `range`. This object 'contains' all the numbers between a certain range. For example,\n\n::: {#b74c8225 .cell execution_count=15}\n``` {.python .cell-code}\nrange(0,5)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nrange(0, 5)\n```\n:::\n:::\n\n\ncover the numbers $0-4$, and is somewhat equivalent to `[0,1,2,3,4]` (for looping purposes). Of course, we can choose a *much* bigger number:\n\n::: {#e3eea2a2 .cell execution_count=16}\n``` {.python .cell-code}\nfor i in range(0,1000):\n    print(i)\n```\n:::\n\n\n will print *every number* between $0$ and $1000$. This can be useful if you need to loop through multiple objects by indexing.\n\n\n\n## Building your own machines\n\nWe'll wrap this session up by looking at custom functions and modules. So far, we've only used built-in functions or those from other people's modules. But we can make our own!\n\nWe've only ever **called** functions - this is what we do when we use them. All functions need a **definition**, this is the code that gets run when they're called.\n\n### The function definition\n\nFunctions are machines. They take some inputs, run some code with those inputs, and spit out **one** output. We need to define how they work before we use them. We should specify\n\n* A name\n* Some inputs\n* The code to run (the machine itself)\n* An output\n\nWe include these in three steps\n\n1. The first line of the function definition (the *function signature*) specifies the name and inputs\n2. We then **indent** all the code we want to run with our inputs\n3. We end with a `return` statement, specifying the output\n\n::: {#f05b5c3b .cell execution_count=17}\n``` {.python .cell-code}\ndef insert_function_name_here(input_1_name, input_2_name, ...):\n    # Code code code\n    return output\n```\n:::\n\n\nFor example, let's create a function that converts centimetres to metres.\n\n::: {#09184b5e .cell execution_count=18}\n``` {.python .cell-code}\ndef cm_to_m(value_in_cm):\n    value_in_m = value_in_cm / 100\n    return value_in_m\n```\n:::\n\n\nTaking it apart, we have\n\n* **Name**: `cm_to_m`\n* **Inputs** (just one): `value_in_cm`\n* **Code** (just one line): `value_in_m = value_in_cm / 100`\n* **Output**: `value_in_m`\n\nImportantly, **nothing happens when you run this code**. Why? Because you've only defined the function, *you haven't used it yet*.\n\nTo use this function, we need to call it. Let's convert $10\\text{ cm}$ to $\\text{m}$.\n\n::: {#645c84f1 .cell execution_count=19}\n``` {.python .cell-code}\ndef cm_to_m(value_in_cm):\n    value_in_m = value_in_cm / 100\n    return value_in_m\n\ncm_to_m(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n0.1\n```\n:::\n:::\n\n\nWhen we call the function, it runs with `value_in_cm = 10`.\n\nThat's it! Every function that you use, built-in or imported, looks like this.\n\nBecause functions must be defined before called, and defining them produces no output, **best practice is to place functions at the top of your script**, below the import statements.\n\n### Docstrings\nSomething you'll spot on all professional functions are docstrings. This is what Python spits out with the `help()` function. You can make your own by writing it within triple quotes **immediately after the signature** `''' '''`:\n\n::: {#2a63359a .cell execution_count=20}\n``` {.python .cell-code}\ndef cm_to_m(value_in_cm):\n    \"\"\"Converts centimetres to metres\"\"\"\n    value_in_m = value_in_cm / 100\n    return value_in_m\n\ncm_to_m(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n0.1\n```\n:::\n:::\n\n\nThat said, the best way to ensure clarity is to use a clear name.\n\n### Creating modules\n\nWhat if you need to write lots of functions? We could write unit converters like above for hundreds of possibilities.\n\nIt's useful to tuck these away in their own file, so they don't clog up your main.py.\n\nLet's make a new file called **conversions.py**, and move your function into it. Delete it from your current file.\n\nThen, to make sure it works, let's make a new converter too, from centimetres to inches. Your **conversions.py** file should look like:\n\n::: {#95697c92 .cell execution_count=21}\n``` {.python .cell-code}\ndef cm_to_m(value_in_cm):\n    \"\"\"Converts centimetres to metres\"\"\"\n    value_in_m = value_in_cm / 100\n    return value_in_m\n\ndef cm_to_in(value_in_cm):\n    \"\"\"Converts centimetres to inches\"\"\"\n    value_in_inches = value_in_cm / 2.54\n    return value_in_inches\n```\n:::\n\n\nLet's make another script now called **main.py**. We'll run our conversions here by pulling in the functions from **conversions.py**.\n\nInside **main.py**, you'll need to import conversions.py. To access the functions, you'll need to use `.` to look inside the module as usual:\n\n::: {#382ef648 .cell execution_count=22}\n``` {.python .cell-code}\nimport conversions\nmetres = conversions.cm_to_m(10)\ninches = conversions.cm_to_in(10)\n\nprint(\"10cm is \" + metres + \"m\")\nprint(\"10cm is \" + inches + \"\\\"\")\n```\n:::\n\n\n> To include a double quote \" inside a string made of double quotes, escape it with a backslash: `\\\"`.\n\nCongratulations, you've made your first module!\n\n",
    "supporting": [
      "6 - Programming_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}