[
  {
    "objectID": "Project/project.html",
    "href": "Project/project.html",
    "title": "Project landing page",
    "section": "",
    "text": "Project landing page",
    "crumbs": [
      "Project",
      "Project landing page"
    ]
  },
  {
    "objectID": "WIPs/6 - Programming.html",
    "href": "WIPs/6 - Programming.html",
    "title": "Programming Building Blocks",
    "section": "",
    "text": "In this workshop we cover the building blocks for developing more complex code, looking at\n\nUnderstanding variable types and methods\nConditionals\nLoops\nCustom functions",
    "crumbs": [
      "WIPs",
      "Programming Building Blocks"
    ]
  },
  {
    "objectID": "WIPs/4 - Version Control.html",
    "href": "WIPs/4 - Version Control.html",
    "title": "Version Control",
    "section": "",
    "text": "In this workshop we cover using GitHub for version control, looking specifically at\n\nHow to use create a repo and commit to it\nHow to push and pull from the command line\nHow to integrate with VS code\nHow to clone and fork other repositories",
    "crumbs": [
      "WIPs",
      "Version Control"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html",
    "href": "WIPs/2 - Data processing.html",
    "title": "Data Processing",
    "section": "",
    "text": "In this second workshop we will cover\nThis hands-on course – directed at intermediate users – looks at using the pandas module to transform and visualise tabular data.",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#setting-up",
    "href": "WIPs/2 - Data processing.html#setting-up",
    "title": "Data Processing",
    "section": "Setting up",
    "text": "Setting up\n\nIntroducing pandas\nPandas is a Python module that introduces dataframes to Python. It gives us the tools we need to clean and transform data with Python.\nTo be able to use the functions included in pandas, we have to first import it:\nimport pandas as pd\npd is the usual nickname for the pandas module.\n\nIf you get an error, like No module named 'pandas', you’ll need to install it first, using either conda install pandas or pip install pandas, depending on your Python installation.\n\n\nThe DataFrame object\nPandas is built upon one key feature: the DataFrame class. In Python we have different built-in types, like int for integers and string for characters. Pandas introduces a new type, DataFrame, which stores data like a spreadsheet.\n\n\n\nSetting up the workspace\nTo make life easy, we should set up our workspace well.\n\nOpen your project folder using your file explorer, and create a new folder called “data”.\nMove your data into this folder.\nNext, open your project in Spyder, and create a new script called “analysis.py”.\nOpen the “Files” tab in Spyder and check that you see two objects:\n\nThe file “analysis.py”\nThe folder “data”\n\n\n\n\nImporting data\nPandas offers a simple way to access data with its read.csv() function. We’ll save it into the variable df_raw:\ndf_raw = pd.read_csv(\"data/name_of_file_here.csv\")\n\nYou can also provide a URL instead of a file path!\n\n\n\nAside - File Paths and backslashes\nJust a quick detour to discuss file paths of which there are two types: absolute and relative\n\nAbsolute\nAbsolute file paths always start at the “top” of your file system, e.g. one of the drives (like C:) for Windows users, so they are never ambiguous. It’s like providing your full address from country to street number.\nC://Users/my_username/research/data/really_important_secret_data.csv\n\n\nRelative\nRelative file paths start from your current file location. For files in my current folder, I just provide their name - like referring to another house on your street as “number 7”. Let’s assume we’re in the research folder.\nfile_in_my_current_folder.csv\nWe can go to down folders from our current location:\ndata/really_important_secret_data.csv\nAnd we can go up folders from our current location\n../../this_file_is_two_levels_up.csv\nOr a combination of the two (e.g. up one, then down into a different folder)\n../not_research/this_file_is_not_research.csv\nWhat matters is that the relative reference depends on where your code is and will break if you move the script!\n\n\nBackslashes\nOne last note: Windows uses backslashes for their file paths\nC:\\\\Users\\...\nBut Python uses backslashes as an escape character. For example, \"\\n\" is a newline, \"\\u1234\" is the unicode character U+1234 and confusingly \"\\\\\" is a single backslash. So we have to modify all Windows file paths to either\nC:\\\\\\\\Users\\\\...\n\nOR\n\nC://Users/...\nYou can choose whichever you prefer.\n\n\n\nInitial look at the data\nLet’s get back to data.\nWe can investigate the size of the data thanks to the shape attribute attached to all pandas dataframes:\ndf_raw.shape\nThe dataset contains dozens of columns. What are their names?\ndf_raw.columns\nLet’s subset our data to focus on a handful of variables.\n\n\nCreating a backup\nData analysis in Python is safe because our variables are copies of the data - we aren’t actually changing the files until we explicitly overwrite them. However, Python also has no undo, so if I delete something in my analysis, I can’t get it back - I have to start all over again.\nOne way to mitigate this issue is by making a copy of the data\ndf = df_raw.copy()\nNow we have two variables: df is what we’ll use, and df_raw stores the raw data. If we ever need to restart, we can simply run df = df_raw.copy().",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#accessing-and-filtering-data",
    "href": "WIPs/2 - Data processing.html#accessing-and-filtering-data",
    "title": "Data Processing",
    "section": "Accessing and Filtering Data",
    "text": "Accessing and Filtering Data\nSo how do we access our data in Python? We use a type of indexing introduced by pandas, which revolves around using square brackets after the dataframe: df[...].\n\nAccessing columns\nTo access a column, index with its name:\ndf[\"column_name\"]\nWe can access multiple by providing a list of names\n# Save the names in a list and then index\ncolumn_names = [\"name_1\", \"name_2\"]\ndf[column_names]\n\n# This is equivalent to\ndf[[\"name_1\", \"name_2\"]]\nIf we want to do anything with it (like statistics or visualisation), it’s worth saving the column(s) as a new variable\ndf_subset = df[[\"name_1\", \"name_2\"]]\n\n\nAccessing rows\nThere’s a few ways to access rows. The easiest is by slicing - if you want rows 5 to 10, use df[5 : 10]\n\nNote that the end row is not included\n\ndf[start_row : end_row]\nIf you want to access a single row, we need to use df.loc[] or df.iloc[]. These are the go-to methods for accessing data if the above indexing isn’t sufficient.\n\ndf.loc[] accesses rows by label (defaults to row number but could be anything)\ndf.iloc[] accesses rows by row number exclusively\n\nFor a single row\ndf.loc[row_label]\ndf.iloc[row_num]\nFinally, we can filter specific rows by a condition on one of the variables, e.g. only rows where variable \\(x &gt; 15\\).\ndf[df[\"column_x\"] &gt; 15]\n# Or any other condition\nAs with the column case, it’s useful to save this as a variable\ndf_filtered = df[df[\"column_x\"] &gt; 15]",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#basic-statistics",
    "href": "WIPs/2 - Data processing.html#basic-statistics",
    "title": "Data Processing",
    "section": "Basic statistics",
    "text": "Basic statistics\nHow might we perform some basic statistics on our data?\nTo check what kind of data each column is stored as, we can use the dtypes attribute:\ndf.dtypes\n\nIn general, pandas will bring in numbers with float64 and non-numeric data with object.\n\nThe describe() method is useful for descriptive statistics about our numerical columns:\ndf.describe()\nHowever, it will only show the two first ones and two last ones. We can focus on a specific column instead, for example one that was hidden previously:\ndf[\"column\"].describe()\nOr a categorical column:\ndf[\"categorical_column\"].describe()\n\nFor a categorical column, the information shown is different: for example, how many unique values there are, and what the most common value is.\n\nWhat if you want specific statistics about a particular column? Usually there are methods available:\n# Applicable to all columns\ndf[\"column\"].count()\ndf[\"column\"].unique()\n\n# For numeric columns only\ndf[\"numeric_column\"].min()\ndf[\"numeric_column\"].max()\ndf[\"numeric_column\"].mean()\ndf[\"numeric_column\"].median()\ndf[\"numeric_column\"].std()\n# ...\nWe can use these methods to filter our data. For example, the row which has the maximum value of variable \\(x\\) is\nx_max = df[\"variable_x\"].max()\ndf[df[\"variable_x\"] == x_max]\n\n# Or in one line\ndf[df[\"variable_x\"] == df[\"variable_x\"].max()]\nbecause we are looking for the row in df[\"variable_x\"] (the whole column) that has the value df[\"variable_x\"].max().",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#challenge",
    "href": "WIPs/2 - Data processing.html#challenge",
    "title": "Data Processing",
    "section": "Challenge",
    "text": "Challenge\nReduce your dataset to \\(\\le 5\\) variables (columns) and \\(\\le 100\\) rows using conditions by filtering down to a particular subset of your data.",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#adding-and-removing-columns",
    "href": "WIPs/2 - Data processing.html#adding-and-removing-columns",
    "title": "Data Processing",
    "section": "Adding and removing columns",
    "text": "Adding and removing columns\nSometimes we need to add new columns. It’s the same process as overwriting existing columns - let’s make a new column called “zeroes” where every row is 0\ndf[\"zeroes\"] = 0\nWe can also send in a column, for example\ndf[\"copy_of_x\"] = df[\"column_x\"]\nPerhaps most usefully, we can manipulate the column we send in. For example, the deviation from the mean \\[|\\bar{x} - x_i|\\] can be computed for each row:\ncol_x = df[\"column_x\"]\navg_x = df[\"column_x\"].mean()\n\ndf[\"deviation_from_mean\"] = abs(col_x - avg_x)\n\n# Or all together on one line,\ndf[\"deviation_from_mean\"] = abs(df[\"column_x\"] - df[\"column_x\"].mean())\nwhere abs(...) takes the absolute value\nNotice that we subtracted a value from a column. We can also perform mathematics with multiple columns:\ndf[\"product\"] = df[\"column_x\"]*df[\"column_y\"]\nLet’s remove these new columns that we don’t need with the method df.drop(columns = [...]):\ndf.drop(columns = [\"zeroes\", \"copy_of_x\", \"deviation_from_mean\", \"product\"])",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#summaries",
    "href": "WIPs/2 - Data processing.html#summaries",
    "title": "Data Processing",
    "section": "Summaries",
    "text": "Summaries\nAfter cleaning up our data, we need to analyse it. This usually involves some kind of aggregation. For example, what is the average \\(x\\) per year? requires aggregating over variable \\(x\\) for each year.\nFirst, we need to group by a specific variable\ngb = df.groupby(\"year\")\nThis thing in itself is a pretty abstract Python object, best thought of as a dataframe where we’ve identified a grouping variable.\nNext, we need to apply some aggregation to it (the groupby tells it to do it for each year)\navg_x_per_year = gb[\"variable_x\"].agg(\"mean\")\nOf course, we could have done this in one line:\navg_x_per_year = df.groupby(\"year\").agg(\"mean\")\nThis is a really useful tool, because now we have something we can visualise. As the next session will show us, the visualisation tools generally just take in numbers and turn them into dots. We need to do the stats beforehand.\nAs a taster, try running\navg_x_per_year.plot()",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#exporting-results",
    "href": "WIPs/2 - Data processing.html#exporting-results",
    "title": "Data Processing",
    "section": "Exporting results",
    "text": "Exporting results\nThe last step in the process is saving the data. Let’s say we want to take that final dataframe and export it to a csv. That’s what the df.to_csv() method is for\navg_x_per_year.to_csv(\"data/avg_x_per_year.csv\")\nThis will save the dataframe to a .csv file and place it in the data folder.",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "WIPs/2 - Data processing.html#resources",
    "href": "WIPs/2 - Data processing.html#resources",
    "title": "Data Processing",
    "section": "Resources",
    "text": "Resources\n\nOfficial pandas documentation\n\nGetting started\n10 Minutes to pandas\nUser guide\n\nMore visualisation modules:\n\nAltair\nBokeh\nVega\nMatplotlib\n\nOur compilation of useful Python links",
    "crumbs": [
      "WIPs",
      "Data Processing"
    ]
  },
  {
    "objectID": "Workshops/Workshops.html",
    "href": "Workshops/Workshops.html",
    "title": "Workshops landing page",
    "section": "",
    "text": "Workshops landing page",
    "crumbs": [
      "Workshops",
      "Workshops landing page"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Python Training Intensive",
    "section": "",
    "text": "Welcome to the Python Training Intensive!",
    "crumbs": [
      "Python Training Intensive"
    ]
  },
  {
    "objectID": "setup.html#setting-up",
    "href": "setup.html#setting-up",
    "title": "Python Training Intensive",
    "section": "Setting Up",
    "text": "Setting Up\nWe are going to use Spyder for writing and running Python. This is a friendly interactive development environment (IDE) aimed at researchers. However, you are more than welcome to use your own!\nPlease set up Python and your IDE in advance.\nIf you don’t have Python or an IDE, we recommend installing Spyder, which comes with Python.",
    "crumbs": [
      "Python Training Intensive"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html",
    "href": "WIPs/1 - Fundamentals.html",
    "title": "The Fundamentals",
    "section": "",
    "text": "In this first workshop we will cover",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#introducing-python-and-spyder",
    "href": "WIPs/1 - Fundamentals.html#introducing-python-and-spyder",
    "title": "The Fundamentals",
    "section": "Introducing Python and Spyder",
    "text": "Introducing Python and Spyder\nPython is a programming language that can be used to build programs (i.e. a “general programming language”), but it can also be used to analyse data by importing a number of useful modules.\nWe are using Spyder to interact with Python more comfortably. If you have used RStudio to interact with R before, you should feel right at home: Spyder is a program designed for doing data science with Python.\nPython can be used interactively in a console, or we can build scripts and programs with it, making the most out of Spyder’s code editor.\nWe will start by using the console to work interactively. This is our direct line to the computer, and is the simplest way to run code. Don’t worry about any unfamiliar language, fonts or colours - we can ignore most of it for now - all you need to know is that\n\nIn [1]: ... is code that we’ve sent to the computer, and\nOut[1]: ... is its response.",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#first-glance-arithmetic",
    "href": "WIPs/1 - Fundamentals.html#first-glance-arithmetic",
    "title": "The Fundamentals",
    "section": "First glance: arithmetic",
    "text": "First glance: arithmetic\nTo start with, we can use Python like a calculator. Type the following commands in the console, and press Enter to execute them:\n1 + 1\n2 * 3\n4 / 10\n5 ** 2\nAfter running each command, you should see the result as an output.",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#variables",
    "href": "WIPs/1 - Fundamentals.html#variables",
    "title": "The Fundamentals",
    "section": "Variables",
    "text": "Variables\nLike language, Python has nouns and verbs. We call the nouns variables: they are the ‘things’ we manipulate with our code.\nEssentially, a variable is a named container. We access it by its name, and we get its value.\nTo create a variable, you need to choose a name and a value with name = value. For example\nexample_int = 42\nWhenever you use the variable’s name, Python will now access its value:\nexample_int\nWe can use the variables in place of the values\nexample_float = 5.678\nproduct = example_int * example_float\nproduct\n\nSpyder helps us with extra panels and features apart from the Console. To see what variables you have created, look at the “Variable explorer” tab in the top right.\n\n\nTypes\nVariables have different types. So far, we’ve just looked at storing numbers, of which there are three types:\n\nint - integers store whole numbers, e.g. 1, 5, 1000, -3.\nfloat - floating point numbers store decimals and scientific notation, e.g. 1.5, -8.97, 4e-6.\ncomplex - complex numbers express the imaginary unit with j, e.g. z = 1+2j is \\(z = 1+2i\\).\n\nLet’s look at some other types\n\nBooleans\nEven simpler than integers is the boolean type. These are either 1 or 0 (True or False), representing a single binary unit (bit). Don’t be fooled by the words, these work like numbers: True + True gives 2.\nexample_bool = True\n\nIn Python, the boolean values True and False must begin with a capital letter.\n\n\n\nStrings\nLet’s look at variable types which aren’t (necessarily) numbers. Sequences are variables which store multiple pieces of data. For example, strings store a sequence of characters and are created with quotation marks 'blah blah blah' or \"blah blah blah\":\nexample_string = 'This is an example of a string!'\n\n\nLists\nWe can also create lists, which will store several variables (not necessarily of the same type). We need to use square brackets for that:\nexample_numbers = [38, 3, 54, 17, 7]\nexample_diverse = [3, 'Hi!', 9.0]\nLists are very flexible as they can contain any number of items, and any type of data. You can even nest lists inside a list, which makes for a very flexible data type.\nOperations on sequences are a bit different to numbers. We can still use + and *, but they will concatenate (append) and duplicate, rather than perform arithmetic.\nexample_string + ' How are you?'\nexample_numbers + example_diverse\n3 * example_numbers\nHowever, depending on the variable, some operations won’t work:\nsentence + favNumber\nThere are other data types like tuples, dictionaries and sets, but we won’t look at those in this session. Here’s a summary of the ones we’ve covered:\n\n\n\n\n\n\n\n\n\n\nCategory\nType\nShort name\nExample\nGenerator\n\n\n\n\nNumeric\nInteger\nint\n3\nint()\n\n\nNumeric\nFloating Point Number\nfloat\n4.2\nfloat()\n\n\nNumeric\nBoolean\nbool\nTrue\nbool()\n\n\nSequence\nString\nstr\n'A sentence '\n\" \" or ' ' or str()\n\n\nSequence\nList\nlist\n['apple', 'banana', 'cherry']\n[ ] or list()\n\n\n\nThe generator commands are new. We use these to manually change the variable type. For example,\nint(True)\nyields 1, converting a boolean into an integer. These commands are functions, as opposed to variables - we’ll look at functions a bit later.\n\n\n\nIndexing\nWe can access part of a sequence by indexing. Sequences are ordered, starting at 0, so the first element has index 0, the second index 1, the third 2 and so on. For example, see what these commands return:\nexample_string[0]\nexample_string[6]\nexample_numbers[4]\nIf you want more than one element in a sequence, you can slice. Simple slices specify a range to slice, from the first index to the last, but not including the last. For example:\nmyList[0:4]\nThat command returns elements from position 0 up to - but not including! - position 4.",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#scripts",
    "href": "WIPs/1 - Fundamentals.html#scripts",
    "title": "The Fundamentals",
    "section": "Scripts",
    "text": "Scripts\nSo far, we’ve been working in the console, our direct line to the computer. However, it is often more convenient to use a script. These are simple text files which store code and run when we choose. They are useful to\n\nwrite code more comfortably,\nstore clearly defined steps in chronological order,\nshare a process with peers easily, and\nmake your work reproducible\n\nLet’s create a folder system to store our script in by creating a project.\n\nPress Projects &gt; New project... and name your project, perhaps “python_training”.\nCreate a new script with ctrl+N, File &gt; New file... or the new file button.\n\nYou should now see a script on the left panel in Spyder, looking something like this:\nTry typing a line of code in your new script, such as\nexample_message = \"This is an example message\"\nexample_message\nPress F9 to run each line, or ctrl+enter for the whole script. You should see something like the following appear in the console (depending on how you ran it):\nWe’ll work out of a script for the rest of the session. Don’t forget to save your script by pressing ctrl+S or the save button. )",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#functions",
    "href": "WIPs/1 - Fundamentals.html#functions",
    "title": "The Fundamentals",
    "section": "Functions",
    "text": "Functions\nFunctions are little programs that do specific jobs. These are the verbs of Python, because they do things to and with our variables. Here are a few examples of built-in functions:\nlen(myList)\nmin(myList)\nmax(myList)\nsum(myList)\nround(otherNumber)\nFunctions always have parentheses () after their name, and they can take one or several arguments, or none at all, depending on what they can do, and how the user wants to use them.\nHere, we use two arguments to modify the default behaviour of the round() function:\nround(otherNumber, 2)\n\nNotice how Spyder gives you hints about the available arguments after typing the function name?\n\n\nOperators\nOperators are a special type of function in Python with which you’re already familiar. The most important is =, which assigns values to variables. Here is a summary of some important operators, although there are many others:\n\nGeneral\n\n\n\n\n\n\n\n\n\nOperator\nFunction\nDescription\nExample command\n\n\n\n\n=\nAssignment\nAssigns values to variables\na = 7\n\n\n#\nComment\nExcludes any following text from being run\n# This text will be ignored by Python\n\n\n\n\n\nMathematical\n\n\n\n\n\n\n\n\n\n\nOperator\nFunction\nDescription\nExample command\nExample output\n\n\n\n\n+\nAddition\nAdds or concatenates values, depending on variable types\n7 + 3 or \"a\" + \"b\"\n10 or 'ab'\n\n\n-\nSubtraction\nSubtracts numerical values\n8 - 3\n5\n\n\n*\nMultiplication\nMultiplies values, depending on variable types\n7 * 2 or \"a\" * 3\n14 or 'aaa'\n\n\n/\nDivision\nDivides numerical vlues\n3 / 4\n0.75\n\n\n**\nExponentiation\nRaises a numerical value to a power\n7 ** 2\n49\n\n\n%\nRemainder\nTakes the remainder of numerical values\n13 % 7\n6\n\n\n\n\n\nComparison\n\n\n\n\n\n\n\n\n\n\nOperator\nFunction\nDescription\nExample command\nExample output\n\n\n\n\n==\nEqual to\nChecks whether two variables are the same and outputs a boolean\n1 == 1\nTrue\n\n\n!=\nNot equal to\nChecks whether two variables are different\n'1' != 1\nTrue\n\n\n&gt;\nGreater than\nChecks whether one variable is greater than the other\n1 &gt; 1\nFalse\n\n\n&gt;=\nGreater than or equal to\nChecks whether greater than (&gt;) or equal to (==) are true\n1 &gt;= 1\nTrue\n\n\n&lt;\nLess than\nChecks whether one variable is less than the other\n0 &lt; 1\nTrue\n\n\n&lt;=\nLess than or equal to\nChecks whether less than (&lt;) or equal to (==) are true\n0 &lt;= 1\nTrue",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#finding-help",
    "href": "WIPs/1 - Fundamentals.html#finding-help",
    "title": "The Fundamentals",
    "section": "Finding help",
    "text": "Finding help\nTo find help about a function, you can use the help() function, or a ? after a function name:\nhelp(max)\nprint?\nIn Spyder, you can use the Ctrl + I keyboard shortcut to open the help in a separate pane.\nFor a comprehensive manual, go to the official online documentation. For questions and answers, typing the right question in a search engine will usually lead you to something helpful. If you can’t find an answer, StackOverflow is a great Q&A community.",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#modules",
    "href": "WIPs/1 - Fundamentals.html#modules",
    "title": "The Fundamentals",
    "section": "Modules",
    "text": "Modules\nPython, on its own, requires a lot of manual programming for advanced tasks. What makes it versatile is the capacity to use other people’s code with modules.\nTo bring in advanced variables and functions that other’s have made, we need to import the module. For example\npi\nreturns an error, because it’s undefined. But the math module contains a variable called pi:\nimport math\nmath.pi\n\nTo access objects from within a module, we use a full stop: module.object_inside.\n\n\nNumPy for arrays\nArrays are a data type introduced by numpy, a module with many functions useful for numerical computing.\nFor example, you can convert the list we created before to then do mathematical operations on each one of its elements:\nimport numpy as np\nexample_array = np.array(example_numbers)\nexample_array * 2\n\n\nPandas for dataframes\npandas introduces dataframes, which are often used to store two-dimensional datasets with different kinds of variables in each column. If your data is stored as a spreadsheet, you probably want to import it with a pandas function.\nHere is an example of creating a pandas dataframe from scratch, populating it by hand:\nimport pandas as pd\n\n# Create initial dataframe\ndf = pd.DataFrame(columns=['Name', 'Age'])\n\n# Populate with data\ndf.loc[1] = 'Josephine', 70\ndf.loc[2] = 'Dilsah', 38\n\ndf\n\nYou can double-click on a dataframe in the Variable explorer to explore it in a separate window.\n\n\n\nMatplotlib for visualisation\nmatplotlib is a large collection of data visualisation functions, and pyplot is a submodule of matplotlib that contains essentials.\nimport matplotlib.pyplot as plt\nplt.plot(example_array)\nThis shows a plot in the Plots tab of Spyder.\n\nIn a Python shell, you might have to use the plt.show() command to show the plot.\n\nThe default look is a line plot that joins all the points, but we can style a plot with only a few characters:\n# blue circles\nplt.plot(example_array, 'bo')\n\n# green squares, dashed line:\nplt.plot(example_array, 'gs--')\nExtra arguments can be used to style further:\n# red, diamonds, solid line; change width of line and size of diamonds:\nplt.plot(example_array, 'rd-', linewidth=3, markersize=10)\nTo find out about the styling shorthand and all other arguments, look at the documentation:\nplt.plot?\n\n\nInstalling modules that aren’t built in\nThe math module is built-in - the module came when I installed Python, and the numpy, pandas and matplotlib come with conda installations. Most other modules live online, so we need to download and install them first.\nInstalling modules depends on whether you have a conda environment or not. To check, run\nconda\n\n\n\n\n\n\n\nMessage\nconda Environment?\n\n\n\n\nconda is a tool for managing and deployi... or something similar\nYes\n\n\nNameError: name 'conda' is not defined\nNo\n\n\n\n\nIf you have a conda environment\nYou can install packages with\nconda install package_name\n\nYou likely have a conda environment if you installed Anaconda or you installed Spyder 6 (Since Oct 2024)\n\n\n\nIf you do not have a conda environment\nYou can install packages with\npip install package_name\n\nYou likely have a pip environment if you installed Python manually and/or are not using Spyder\n\n\n\n\nPlotly Express for interactive visualisations\nOne module that isn’t built-in is plotly, which we can use for interactive visualisations.\nimport plotly.io as pio\nimport plotly.express as px\n\n# Set renderer\npio.renderers.default='browser'\n\n# Create bar plot\npx.bar(df, x = \"Name\", y = \"Age\")",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#saving-your-work",
    "href": "WIPs/1 - Fundamentals.html#saving-your-work",
    "title": "The Fundamentals",
    "section": "Saving your work",
    "text": "Saving your work\nPress “Save” or Ctrl + S to save your script.\nYour project can be reopened from the “Projects” menu in Spyder.\nBy default, your variables are not saved, which is another reason why working with a script is important: you can execute the whole script in one go to get everything back. You can however save your variables as a .spydata file if you want to (for example, if it takes a lot of time to process your data).",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/1 - Fundamentals.html#summary",
    "href": "WIPs/1 - Fundamentals.html#summary",
    "title": "The Fundamentals",
    "section": "Summary",
    "text": "Summary\nThis morning we looked at a lot of Python features, so don’t worry if they haven’t all sunk in. Programming is best learned through practice, so keep at it! Here’s a rundown of the concepts we covered\n\n\n\n\n\n\n\nConcept\nDesctiption\n\n\n\n\nThe console vs scripts\nThe console is our window into the computer, this is where we send code directly to the computer. Scripts are files which we can write, edit, store and run code, that’s where you’ll write most of your Python.\n\n\nVariables\nVariables are the nouns of programming, this is where we store information, the objects and things of our coding. They come in different types like integers, strings and lists.\n\n\nIndexing\nIn order to access elements of a sequence variable, like a list, we need to index, e.g. example_numbers[2]. Python counts from 0.\n\n\nFunctions\nFunctions are the verbs of programming, they perform actions on our variables. Call the function by name and put inputs inside parentheses, e.g. round(2.5)\n\n\nHelp\nRunning help( ... ) will reveal the help documentation about a function or type.\n\n\nPackages\nWe can bring external code into our environment with import .... This is how we use packages, an essential for Python. Don’t forget to install the package first!",
    "crumbs": [
      "WIPs",
      "The Fundamentals"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html",
    "href": "WIPs/3 - Visualisation.html",
    "title": "Visualisation",
    "section": "",
    "text": "In this third workshop we will cover\nSee analysis.py for seaborn stuff.",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html#setting-up",
    "href": "WIPs/3 - Visualisation.html#setting-up",
    "title": "Visualisation",
    "section": "Setting up",
    "text": "Setting up\nWith the data manipulation tools from pandas, we can now visualise our data. For this workshop we’ll be working from the “Players2024.csv” dataset, which we should bring in with pandas:\nimport pandas as pd\ndf = pd.read_csv(\"data/Players2024.csv\")\nTake a quick peak at the dataset to remind yourself\nprint(df)",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html#seaborn-for-simple-visualisations",
    "href": "WIPs/3 - Visualisation.html#seaborn-for-simple-visualisations",
    "title": "Visualisation",
    "section": "Seaborn for simple visualisations",
    "text": "Seaborn for simple visualisations\nTo begin our visualisations, we’ll use the package seaborn, which allows you to quickly whip up decent graphs.\nimport seaborn as sns\n\nIt’s called “seaborn” as a reference to fictional character Sam Seaborn, whose initials are “sns”.\n\nSeaborn has three plotting functions\nsns.catplot(...) # for categorical plotting, e.g. bar plots, box plots etc.\nsns.relplot(...) # for relational plotting, e.g. line plots, scatter plots\nsns.displot(...) # for distributions, e.g. histograms\nWe’ll begin with the first.\n\nCategorical plots\nCategorical plots are produced with seaborn’s sns.catplot() function. There are two key pieces of information to pass:\n\nThe data\nThe variables\n\nLet’s see if there’s a relationship between the players’ heights and positions, by placing their positions on the \\(x\\) axis and heights on the \\(y\\).\nsns.catplot(data = df, x = \"positions\", y = \"height_cm\")\nOur first graph! This is called a swarm plot; it’s like a scatter plot for categorical variables.\nIt’s already revealed two things to us about the data:\n\nThere are some incorrect heights - nobody is shorter than 25cm!\nSomeone’s position is “missing”\n\nLet’s get rid of these with the data analysis techniques from last session\n# Remove missing position\ndf = df[df[\"positions\"] != \"Missing\"]\n\n# Ensure reasonable heights\ndf = df[df[\"height_cm\"] &gt; 100]\nRun the plot again, it’s more reasonable now\nsns.catplot(data = df, x = \"positions\", y = \"height_cm\")\n\nBar plots\nSwarm plots are interesting but not standard. You can change the plot type with the kind parameter\nsns.catplot(data = df, x = \"positions\", y = \"height_cm\", kind = \"bar\")\n\nMany aspects of your plot can be adjusted by sending in additional parameters and is where seaborn excels.\n\nIt seems like goalkeepers are taller, but not by much. Let’s look at the standard deviation for each position by changing the estimator = parameter (default is mean)\nsns.catplot(data = df, x = \"positions\", y = \"height_cm\", kind = \"bar\", estimator = \"std\")\nClearly there’s a lot less variation in goalkeepers - they’re all tall.\n\n\nBox plots\nLet’s make box plots instead. It’s the same procedure, just change to kind = \"box\" and remove estimator =\nsns.catplot(data = df, x = \"positions\", y = \"height_cm\", kind = \"box\")\nJust as we predicted.\n\n\n\nDistributions\n\nHistograms\nLet’s move to the “Age” parameter now. We can look at the distribution of ages with\nsns.displot(data = df, x = \"Age\")\nLooks a bit funny with those gaps - let’s change the number of bins with bins = 28\nsns.displot(data = df, x = \"Age\", bins = 28)\nNow, what if you wanted to look at the distribution for different variables? We can make a separate distribution for each position with the col = \"position\" argument, specifying a new column for each position\nsns.displot(data = df, x = \"Age\", bins = 28, col = \"positions\")\n\n\nKernel density estimates\nFinally, you don’t have to do histograms. You could also do a Kernel Density Estimate, with kind = \"kde\" (let’s remove bins = and col =)\nsns.displot(data = df, x = \"Age\", kind = \"kde\")\nIf you want a separate line for each position, we should indicate that each position needs a different colour/hue with hue = \"position\"\nsns.displot(data = df, x = \"Age\", hue = \"position\", kind = \"kde\")\n\n\n\nRelational plots\nIt seems like players peak in their mid-twenties, but goalkeepers stay for longer. Let’s see if there’s a relationship between players’ age and height\n\nScatter plots\nWe’ll start with a scatter plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\")\nNot much of a trend there, although the bottom-right looks a bit emptier than the rest (could it be that short old players are the first to retire?).\nWe can use hue = to have a look at positions again\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", hue = \"positions\")\nYup, goalkeepers are tall, and everyone else is a jumble.\n\n\nLine plots\nLet’s do a line plot of the average height per age.\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", kind = \"line\")\nSeems pretty flat, except the ends are a bit weird because there’s not much data. Let’s eliminate everything before 17 and after 38 and plot it\n# Create smaller dataframe\ncondition = (df[\"Age\"] &gt; 17) & (df[\"Age\"] &lt; 38)\ninner_ages = df[condition]\n\n# Line plot\nsns.relplot(data = inner_ages, x = \"Age\", y = \"height_cm\", kind = \"line\")\nLooks a bit shaky but that’s just because it’s zoomed in - notice that we go from 182cm to 184cm. We’ll fix this when we look at matplotlib in the next section.\n\n\nCombining the two\nWe can combine our scatter and line plots together.\n\nMake the first plot as normal\nFor all additional (overlaying) plots, use an axes-level plot instead of sns.relplot() etc. These just draw the points/bars/lines, and are normally behind-the-scenes. There’s one for every plot type, and look like\n\nsns.lineplot()\nsns.scatterplot()\nsns.boxplot()\nsns.histplot()\netc.\n\n\nFor example,\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", hue = \"positions\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\")\n\nYou can’t include kind = inside an axes level plot\n\nLet’s swap the colour variable from the scatter plot to the line plot\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")\nFinally, let’s make the scatter dots smaller with s = 10 and grey with color = \"grey\".\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html#going-deeper-with-matplotlib",
    "href": "WIPs/3 - Visualisation.html#going-deeper-with-matplotlib",
    "title": "Visualisation",
    "section": "Going deeper with matplotlib",
    "text": "Going deeper with matplotlib\nSeaborn is great for simple and initial visualisations, but when you need to make adjustments it gets tricky. At its core, seaborn is just a simple way of using matplotlib, an extensive and popular plotting package. It was created as a way of doing MATLAB visualisations with Python, so if you’re coming from there, things will feel familiar.\nPros\n\nCustomisable. You can tweak almost every parameter of the visualisations\nFast. It can handle large data\nPopular. Lots of people use it, and knowing it will help you collaborate\n\nCons - a bit programmy\n\nSteep-ish learning curve. Creating basic plots can be easy, but its set up with enough complexity that it takes a bit of work to figure out what’s going on.\nCumbersome. You can tweak almost everything, but this means that it can take some effort to tweak anything.\n\nWe’re barely going to touch the matplotlib surface, but we’ll look at some essentials.\nTo begin with, we want to bring in matplotlib as follows\nimport matplotlib.pyplot as plt\n\nSaving plots\nBefore we move to adjusting the plot, let’s just look at how you save it. While you can do this with seaborn, the matplotlib way is also very simple.\nAs a first step, you should make a new folder. Navigate using your file explorer to the project and create a new folder called “plots”.\nNext, save the current plot with plt.savefig(\"place_location_here\"), and we have to do this at the same time that we make the plot. So run all this code at once:\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")\n\nplt.savefig(\"plots/first_saved_plot.png\")\n\n\nMaking modifications\n\nTitles\nNotice that the \\(y\\) axis has an ugly label? That’s because seaborn is just drawing from your dataframe.\nWe can change axis labels with\nplt.ylabel(\"Height (cm)\")\nand similarly you could change plt.xlabel(...).\n\nMake sure you run the above line at the same time as your plotting function. You can either * Highlight all the code and press F9 * Make a cell with #%% and press ctrl + enter\n\nWe can also change the legend title to “Position”\nplt.legend(title = \"Position\")\nAnd its location with loc = \"lower left\"\nplt.legend(title = \"Position\", loc = \"lower left\")\nAnd give the whole plot a title with\nplt.title(\"Players' heights vs ages\")\nAll of these together, with the plot, look like\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")\n\n# Titles\nplt.ylabel(\"Height (cm)\")\nplt.legend(title = \"Position\")\nplt.title(\"Players' heights vs ages\")\n\n\n\nAnnotations\nYou might want to annotate your plot with text and arrows. Text is simple with the plt.text() function; we just need to specify its coordinates and the contents.\nplt.text(38.5, 181, \"Not enough\\ndata for mean\")\n\nThe characters \\n mean ‘new line’\n\nWe could annotate with arrows too. This is more complex,\nplt.annotate(text = \"No short\\nolder players\", xy = [37,165], xytext = [40,172],\n             arrowprops = dict(width = 1, headwidth = 10, headlength = 10, \n                          facecolor = \"black\"))\n\nI’ve split this over multiple lines, but its still one function - check the brackets\n\nAll together, our plot has become\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")\n\n# Titles\nplt.ylabel(\"Height (cm)\")\nplt.legend(title = \"Position\", loc = \"lower left\")\nplt.title(\"Players' heights vs ages\")\n\n# Annotations\nplt.text(38.5, 181, \"Not enough\\ndata for mean\")\nplt.annotate(\"No short\\nolder players\", [37,165], [40,172], \n             arrowprops = dict(width = 1,headwidth = 10,headlength = 10, \n                               facecolor = \"black\"))\n\n\nAxis limits\nThe last feature we’ll look at is editing axis limits. Let’s try to make more room in the bottom left for the legend with the functions plt.xlim() and plt.ylim()\n# Figure level plot\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\n\n# Axes level plot (drop the kind = )\nsns.lineplot(data = inner_ages, x = \"Age\", y = \"height_cm\", hue = \"positions\")\n\n# Titles\nplt.ylabel(\"Height (cm)\")\nplt.legend(title = \"Position\", loc = \"lower left\")\nplt.title(\"Players' heights vs ages\")\n\n# Annotations\nplt.text(38.5, 181, \"Not enough\\ndata for mean\")\nplt.annotate(\"No short\\nolder players\", [37,165], [40,172], \n             arrowprops = dict(width = 1,headwidth = 10,headlength = 10, \n                               facecolor = \"black\"))\n\n# Axis limits\nplt.xlim([10,45])\nplt.ylim([150,210])\nI’m not sure that looks any better, but you get the idea!",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html#interactivity-with-plotly",
    "href": "WIPs/3 - Visualisation.html#interactivity-with-plotly",
    "title": "Visualisation",
    "section": "Interactivity with plotly",
    "text": "Interactivity with plotly\nFor the last part of this section, we’re going to briefly look at making interactive plots with plotly.\nWe bring in the tools with\nimport plotly.express as px\n\nYou’ll probably need to install it first - use either\nconda install plotly\nOR\npip install plotly\ndepending on your installation.\n\nPlotly works by creating a visualisation like we’ve been doing, and then loading it into something dynamic, like a web browser. Spyder does not support interactive plots. This means we need to change the default settings with\nimport plotly.io as pio\npio.renderers.default = \"browser\"\nNow, plots should all load in your default browser.\n\nThe basics\nWe make plotly graphs very similarly to seaborn. Let’s take our first plot from above,\nsns.relplot(data = df, x = \"Age\", y = \"height_cm\", s = 10, color = \"grey\")\nand turn it into a plotly one.\n\nWe need to use px.scatter instead of sns.relplot\nWe need to use data_frame = instead of data =\nLet’s remove the s = and color = for now\nSave the plot as a variable\n\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\")\nNotice how you can hover over the points now? It’s interactive!\n\n\nIntroducing more info and neatening up\nLike seaborn’s “hue”, we can use color = to introduce a third variable\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"position\")\nAnd like seaborn’s “col”, we can facet with facet_col =\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"position\",\n           facet_col = \"positions\")\nPersonally, I think these are too squished. We can specify the maximum number of columns with facet_col_wrap =\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"positions\",\n           facet_col = \"positions\", facet_col_wrap = 2)\nFinally, let’s adjust the information in the hover. We can give each point a name with hover_name = - how about their actual names?\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"positions\",\n           facet_col = \"positions\", facet_col_wrap = 2, hover_name = \"name\")\nAnd let’s also include their nationalities\npx.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"positions\",\n           facet_col = \"positions\", facet_col_wrap = 2, hover_name = \"name\",\n           hover_data = \"nationality\")\n\n\nSaving interactive plots\nSince these are interactive, we can’t save them as normal. The easiest option is to save them as HTML files - like websites - which we can open from our browsers.\nFirst, save the plot into a variable\nfig = px.scatter(data_frame = df, x = \"Age\", y = \"height_cm\", color = \"positions\",\n                 facet_col = \"positions\", facet_col_wrap = 2, hover_name = \"name\",\n                 hover_data = \"nationality\")\nThen, write it to HTML\nfig.write_html(\"plot.html\")",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/3 - Visualisation.html#conclusion",
    "href": "WIPs/3 - Visualisation.html#conclusion",
    "title": "Visualisation",
    "section": "Conclusion",
    "text": "Conclusion",
    "crumbs": [
      "WIPs",
      "Visualisation"
    ]
  },
  {
    "objectID": "WIPs/5 - Dashboards.html",
    "href": "WIPs/5 - Dashboards.html",
    "title": "Dashboards",
    "section": "",
    "text": "In this workshop we look at the basics of creating a dashboard with quarto.",
    "crumbs": [
      "WIPs",
      "Dashboards"
    ]
  }
]